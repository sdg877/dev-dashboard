{"ast":null,"code":"import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js';\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js';\nimport { ClientError } from '../classes/ClientError.js';\nimport { cleanQuery, isGraphQLContentType, isRequestResultHaveErrors, parseGraphQLExecutionResult } from '../lib/graphql.js';\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js';\n// @ts-expect-error todo\nexport const runRequest = async input => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`\n    }\n  };\n  const fetcher = createFetcher(config.method);\n  const fetchResponse = await fetcher(config);\n  if (!fetchResponse.ok) {\n    return new ClientError({\n      status: fetchResponse.status,\n      headers: fetchResponse.headers\n    }, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  if (result instanceof Error) throw result; // todo something better\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers\n  };\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch` ? {\n      ...result.executionResults,\n      ...clientResponseBase\n    } : {\n      ...result.executionResult,\n      ...clientResponseBase\n    };\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult)\n      };\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config))\n      };\n    default:\n      casesExhausted(result);\n  }\n};\nconst executionResultClientResponseFields = $params => executionResult => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined\n  };\n};\nconst parseResultFromResponse = async (response, jsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER);\n  const text = await response.text();\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text));\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text);\n  }\n};\nconst createFetcher = method => async params => {\n  const headers = new Headers(params.headers);\n  let searchParams = null;\n  let body = undefined;\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));\n  }\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n    body = $jsonSerializer.stringify(buildBody(params));\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);\n    }\n  } else {\n    searchParams = buildQueryParams(params);\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...params.fetchOptions\n  };\n  let url = new URL(params.url);\n  let initResolved = init;\n  if (params.middleware) {\n    const result = await Promise.resolve(params.middleware({\n      ...init,\n      url: params.url,\n      operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n      variables: params.request.variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    url = new URL(urlNew);\n    initResolved = initNew;\n  }\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value);\n    });\n  }\n  const $fetch = params.fetch ?? fetch;\n  return await $fetch(url, initResolved);\n};\nconst buildBody = params => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName\n      };\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables\n      }));\n    default:\n      throw casesExhausted(params.request);\n  }\n};\nconst buildQueryParams = params => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n  const searchParams = new URLSearchParams();\n  switch (params.request._tag) {\n    case `Single`:\n      {\n        searchParams.append(`query`, cleanQuery(params.request.document.expression));\n        if (params.request.variables) {\n          searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));\n        }\n        if (params.request.document.operationName) {\n          searchParams.append(`operationName`, params.request.document.operationName);\n        }\n        return searchParams;\n      }\n    case `Batch`:\n      {\n        const variablesSerialized = params.request.variables?.map(v => $jsonSerializer.stringify(v)) ?? [];\n        const queriesCleaned = params.request.query.map(cleanQuery);\n        const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n          query,\n          variables\n        }));\n        searchParams.append(`query`, $jsonSerializer.stringify(payload));\n        return searchParams;\n      }\n    default:\n      throw casesExhausted(params.request);\n  }\n};","map":{"version":3,"names":["ACCEPT_HEADER","CONTENT_TYPE_GQL","CONTENT_TYPE_HEADER","CONTENT_TYPE_JSON","casesExhausted","uppercase","zip","ClientError","cleanQuery","isGraphQLContentType","isRequestResultHaveErrors","parseGraphQLExecutionResult","defaultJsonSerializer","runRequest","input","config","method","request","_tag","document","isMutation","hasMutations","fetchOptions","errorPolicy","fetcher","createFetcher","fetchResponse","ok","status","headers","query","expression","variables","result","parseResultFromResponse","jsonSerializer","Error","clientResponseBase","clientResponse","executionResults","executionResult","executionResultClientResponseFields","data","map","$params","extensions","errors","undefined","response","contentType","get","text","parse","params","Headers","searchParams","body","has","set","join","$jsonSerializer","stringify","buildBody","buildQueryParams","init","url","URL","initResolved","middleware","Promise","resolve","operationName","urlNew","initNew","forEach","value","name","append","$fetch","fetch","URLSearchParams","variablesSerialized","v","queriesCleaned","payload"],"sources":["/Users/sylviadrake-gill/code/dev-dashboard/client/node_modules/graphql-request/src/legacy/helpers/runRequest.ts"],"sourcesContent":["import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js'\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js'\nimport { ClientError } from '../classes/ClientError.js'\nimport type { GraphQLExecutionResultSingle } from '../lib/graphql.js'\nimport {\n  cleanQuery,\n  isGraphQLContentType,\n  isRequestResultHaveErrors,\n  parseGraphQLExecutionResult,\n} from '../lib/graphql.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport type {\n  BatchVariables,\n  Fetch,\n  FetchOptions,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  RequestMiddleware,\n  Variables,\n} from './types.js'\n\ninterface Input {\n  url: string\n  /**\n   * The HTTP method to use for queries. Note that mutations are ALWAYS sent as POST requests ([per spec](https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md?rgh-link-date=2022-06-02T09%3A30%3A53Z)).\n   *\n   * @defaultValue `'POST'`\n   */\n  method?: HTTPMethodInput\n  fetch?: Fetch\n  fetchOptions: FetchOptions\n  headers?: HeadersInit\n  middleware?: RequestMiddleware\n  request:\n    | {\n      _tag: 'Single'\n      variables?: Variables\n      document: {\n        expression: string\n        isMutation: boolean\n        operationName?: string\n      }\n    }\n    | {\n      _tag: 'Batch'\n      query: string[]\n      operationName?: undefined\n      hasMutations: boolean\n      variables?: BatchVariables\n    }\n}\n\n// @ts-expect-error todo\nexport const runRequest = async (input: Input): Promise<ClientError | GraphQLClientResponse<any>> => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single`\n      ? input.request.document.isMutation\n        ? `POST`\n        : uppercase(input.method ?? `post`)\n      : input.request.hasMutations\n      ? `POST`\n      : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`,\n    },\n  }\n  const fetcher = createFetcher(config.method)\n  const fetchResponse = await fetcher(config)\n\n  if (!fetchResponse.ok) {\n    return new ClientError(\n      { status: fetchResponse.status, headers: fetchResponse.headers },\n      {\n        query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n        variables: input.request.variables,\n      },\n    )\n  }\n\n  const result = await parseResultFromResponse(\n    fetchResponse,\n    input.fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n  )\n\n  if (result instanceof Error) throw result // todo something better\n\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers,\n  }\n\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch`\n      ? { ...result.executionResults, ...clientResponseBase }\n      : {\n        ...result.executionResult,\n        ...clientResponseBase,\n      }\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables,\n    })\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult),\n      }\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config)),\n      }\n    default:\n      casesExhausted(result)\n  }\n}\n\nconst executionResultClientResponseFields = ($params: Input) => (executionResult: GraphQLExecutionResultSingle) => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined,\n  }\n}\n\nconst parseResultFromResponse = async (response: Response, jsonSerializer: JsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER)\n  const text = await response.text()\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text))\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text)\n  }\n}\n\nconst createFetcher = (method: 'GET' | 'POST') => async (params: Input) => {\n  const headers = new Headers(params.headers)\n  let searchParams: URLSearchParams | null = null\n  let body = undefined\n\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `))\n  }\n\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    body = $jsonSerializer.stringify(buildBody(params))\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON)\n    }\n  } else {\n    searchParams = buildQueryParams(params)\n  }\n\n  const init: RequestInit = { method, headers, body, ...params.fetchOptions }\n\n  let url = new URL(params.url)\n  let initResolved = init\n\n  if (params.middleware) {\n    const result = await Promise.resolve(\n      params.middleware({\n        ...init,\n        url: params.url,\n        operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n        variables: params.request.variables,\n      }),\n    )\n    const { url: urlNew, ...initNew } = result\n    url = new URL(urlNew)\n    initResolved = initNew\n  }\n\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value)\n    })\n  }\n\n  const $fetch = params.fetch ?? fetch\n  return await $fetch(url, initResolved)\n}\n\nconst buildBody = (params: Input) => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName,\n      }\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n\nconst buildQueryParams = (params: Input): URLSearchParams => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n  const searchParams = new URLSearchParams()\n  switch (params.request._tag) {\n    case `Single`: {\n      searchParams.append(`query`, cleanQuery(params.request.document.expression))\n      if (params.request.variables) {\n        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables))\n      }\n      if (params.request.document.operationName) {\n        searchParams.append(`operationName`, params.request.document.operationName)\n      }\n      return searchParams\n    }\n    case `Batch`: {\n      const variablesSerialized = params.request.variables?.map((v) => $jsonSerializer.stringify(v)) ?? []\n      const queriesCleaned = params.request.query.map(cleanQuery)\n      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n      searchParams.append(`query`, $jsonSerializer.stringify(payload))\n      return searchParams\n    }\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}