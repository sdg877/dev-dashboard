{"ast":null,"code":"import { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js';\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js';\nimport { parseRawRequestArgs } from '../functions/rawRequest.js';\nimport { parseRequestArgs } from '../functions/request.js';\nimport { analyzeDocument } from '../helpers/analyzeDocument.js';\nimport { runRequest } from '../helpers/runRequest.js';\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  url;\n  requestConfig;\n  constructor(url, requestConfig = {}) {\n    this.url = url;\n    this.requestConfig = requestConfig;\n  }\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest = async (...args) => {\n    const [queryOrOptions, variables, requestHeaders] = args;\n    const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal;\n    }\n    const document = analyzeDocument(rawRequestOptions.query, excludeOperationName);\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document,\n        variables: rawRequestOptions.variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    });\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: document.operationName,\n        variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response;\n  };\n  async request(documentOrOptions, ...variablesAndRequestHeaders) {\n    const [variables, requestHeaders] = variablesAndRequestHeaders;\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    const {\n      url\n    } = this;\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal;\n    }\n    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders)\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware\n    });\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response.data;\n  }\n  async batchRequests(documentsOrOptions, requestHeaders) {\n    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);\n    const {\n      headers,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig;\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal;\n    }\n    const analyzedDocuments = batchRequestOptions.documents.map(({\n      document\n    }) => analyzeDocument(document, excludeOperationName));\n    const expressions = analyzedDocuments.map(({\n      expression\n    }) => expression);\n    const hasMutations = analyzedDocuments.some(({\n      isMutation\n    }) => isMutation);\n    const variables = batchRequestOptions.documents.map(({\n      variables\n    }) => variables);\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware\n    });\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url\n      });\n    }\n    if (response instanceof Error) {\n      throw response;\n    }\n    return response.data;\n  }\n  setHeaders(headers) {\n    this.requestConfig.headers = headers;\n    return this;\n  }\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key, value) {\n    const {\n      headers\n    } = this.requestConfig;\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value;\n    } else {\n      this.requestConfig.headers = {\n        [key]: value\n      };\n    }\n    return this;\n  }\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value) {\n    this.url = value;\n    return this;\n  }\n}","map":{"version":3,"names":["callOrIdentity","HeadersInitToPlainObject","parseBatchRequestArgs","parseRawRequestArgs","parseRequestArgs","analyzeDocument","runRequest","GraphQLClient","url","requestConfig","constructor","rawRequest","args","queryOrOptions","variables","requestHeaders","rawRequestOptions","headers","fetch","globalThis","method","requestMiddleware","responseMiddleware","excludeOperationName","fetchOptions","signal","undefined","document","query","response","request","_tag","middleware","operationName","Error","documentOrOptions","variablesAndRequestHeaders","requestOptions","analyzedDocument","data","batchRequests","documentsOrOptions","batchRequestOptions","analyzedDocuments","documents","map","expressions","expression","hasMutations","some","isMutation","setHeaders","setHeader","key","value","setEndpoint"],"sources":["/Users/sylviadrake-gill/code/dev-dashboard/client/node_modules/graphql-request/src/legacy/classes/GraphQLClient.ts"],"sourcesContent":["import type { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport { callOrIdentity, HeadersInitToPlainObject } from '../../lib/prelude.js'\nimport type { BatchRequestDocument, BatchRequestsOptions, BatchResult } from '../functions/batchRequests.js'\nimport { parseBatchRequestArgs } from '../functions/batchRequests.js'\nimport { parseRawRequestArgs } from '../functions/rawRequest.js'\nimport { parseRequestArgs } from '../functions/request.js'\nimport { analyzeDocument } from '../helpers/analyzeDocument.js'\nimport { runRequest } from '../helpers/runRequest.js'\nimport type { RequestDocument, RequestOptions, VariablesAndRequestHeadersArgs } from '../helpers/types.js'\nimport {\n  type GraphQLClientResponse,\n  type RawRequestOptions,\n  type RequestConfig,\n  type Variables,\n} from '../helpers/types.js'\n\n/**\n * GraphQL Client.\n */\nexport class GraphQLClient {\n  constructor(\n    private url: string,\n    public readonly requestConfig: RequestConfig = {},\n  ) {}\n\n  /**\n   * Send a GraphQL query to the server.\n   */\n  rawRequest: RawRequestMethod = async <\n    T,\n    $Variables extends Variables = Variables,\n  >(\n    ...args: RawRequestMethodArgs<$Variables>\n  ): Promise<GraphQLClientResponse<T>> => {\n    const [queryOrOptions, variables, requestHeaders] = args\n    const rawRequestOptions = parseRawRequestArgs<$Variables>(\n      queryOrOptions,\n      variables,\n      requestHeaders,\n    )\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (rawRequestOptions.signal !== undefined) {\n      fetchOptions.signal = rawRequestOptions.signal\n    }\n\n    const document = analyzeDocument(\n      rawRequestOptions.query,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document,\n        variables: rawRequestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: document.operationName,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response\n  }\n\n  /**\n   * Send a GraphQL document to the server.\n   */\n  // dprint-ignore\n  async request<T, V extends Variables = Variables>(document: RequestDocument | TypedDocumentNode<T, V>, ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>): Promise<T>\n  async request<T, V extends Variables = Variables>(options: RequestOptions<V, T>): Promise<T>\n  async request<T, V extends Variables = Variables>(\n    documentOrOptions:\n      | RequestDocument\n      | TypedDocumentNode<T, V>\n      | RequestOptions<V>,\n    ...variablesAndRequestHeaders: VariablesAndRequestHeadersArgs<V>\n  ): Promise<T> {\n    const [variables, requestHeaders] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(\n      documentOrOptions,\n      variables,\n      requestHeaders,\n    )\n\n    const {\n      headers,\n      fetch = globalThis.fetch,\n      method = `POST`,\n      requestMiddleware,\n      responseMiddleware,\n      excludeOperationName,\n      ...fetchOptions\n    } = this.requestConfig\n    const { url } = this\n    if (requestOptions.signal !== undefined) {\n      fetchOptions.signal = requestOptions.signal\n    }\n\n    const analyzedDocument = analyzeDocument(\n      requestOptions.document,\n      excludeOperationName,\n    )\n\n    const response = await runRequest({\n      url,\n      request: {\n        _tag: `Single`,\n        document: analyzedDocument,\n        variables: requestOptions.variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(requestOptions.requestHeaders),\n      },\n      fetch,\n      method,\n      fetchOptions,\n      middleware: requestMiddleware,\n    })\n\n    if (responseMiddleware) {\n      await responseMiddleware(response, {\n        operationName: analyzedDocument.operationName,\n        variables: requestOptions.variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  /**\n   * Send GraphQL documents in batch to the server.\n   */\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documents: BatchRequestDocument<$Variables>[],\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(options: BatchRequestsOptions<$Variables>): Promise<$BatchResult>\n  async batchRequests<\n    $BatchResult extends BatchResult,\n    $Variables extends Variables = Variables,\n  >(\n    documentsOrOptions:\n      | BatchRequestDocument<$Variables>[]\n      | BatchRequestsOptions<$Variables>,\n    requestHeaders?: HeadersInit,\n  ): Promise<$BatchResult> {\n    const batchRequestOptions = parseBatchRequestArgs<$Variables>(\n      documentsOrOptions,\n      requestHeaders,\n    )\n    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig\n\n    if (batchRequestOptions.signal !== undefined) {\n      fetchOptions.signal = batchRequestOptions.signal\n    }\n\n    const analyzedDocuments = batchRequestOptions.documents.map(\n      ({ document }) => analyzeDocument(document, excludeOperationName),\n    )\n    const expressions = analyzedDocuments.map(({ expression }) => expression)\n    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation)\n    const variables = batchRequestOptions.documents.map(\n      ({ variables }) => variables,\n    )\n\n    const response = await runRequest({\n      url: this.url,\n      request: {\n        _tag: `Batch`,\n        operationName: undefined,\n        query: expressions,\n        hasMutations,\n        variables,\n      },\n      headers: {\n        ...HeadersInitToPlainObject(callOrIdentity(headers)),\n        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders),\n      },\n      fetch: this.requestConfig.fetch ?? globalThis.fetch,\n      method: this.requestConfig.method || `POST`,\n      fetchOptions,\n      middleware: this.requestConfig.requestMiddleware,\n    })\n\n    if (this.requestConfig.responseMiddleware) {\n      await this.requestConfig.responseMiddleware(response, {\n        operationName: undefined,\n        variables,\n        url: this.url,\n      })\n    }\n\n    if (response instanceof Error) {\n      throw response\n    }\n\n    return response.data\n  }\n\n  setHeaders(headers: HeadersInit): this {\n    this.requestConfig.headers = headers\n    return this\n  }\n\n  /**\n   * Attach a header to the client. All subsequent requests will have this header.\n   */\n  setHeader(key: string, value: string): this {\n    const { headers } = this.requestConfig\n\n    if (headers) {\n      // todo what if headers is in nested array form... ?\n      // @ts-expect-error todo\n      headers[key] = value\n    } else {\n      this.requestConfig.headers = { [key]: value }\n    }\n\n    return this\n  }\n\n  /**\n   * Change the client endpoint. All subsequent requests will send to this endpoint.\n   */\n  setEndpoint(value: string): this {\n    this.url = value\n    return this\n  }\n}\n\ninterface RawRequestMethod {\n  <T, V extends Variables = Variables>(\n    query: string,\n    variables?: V,\n    requestHeaders?: HeadersInit,\n  ): Promise<GraphQLClientResponse<T>>\n  <T, V extends Variables = Variables>(options: RawRequestOptions<V>): Promise<\n    GraphQLClientResponse<T>\n  >\n}\n\ntype RawRequestMethodArgs<V extends Variables> =\n  | [query: string, variables?: V, requestHeaders?: HeadersInit]\n  | [RawRequestOptions<V>]\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}